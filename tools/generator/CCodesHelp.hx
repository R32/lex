package tools.generator;

import haxe.macro.Expr;

class CCodesHelp {

	public static function typedecl( ct : ComplexType ) {
		return switch (ct) {
		case TPath({name : name}):
			name;
		case null, _:
			"void *";
		}
	}

	public static function typecast( type : String ) {
		if (type == "void *")
			return "";
		if (type.lastIndexOf("*") > 0)
			return '($type)';
		return '($type)(size_t)';
	}

	public static function finalizeActoin( e : Expr, sret = "_ret = " ) {
		switch (e.expr) {
		case EBlock(a):
			var len = a.length;
			if (len == 0)
				return "";
			var lstr = a.map(ExprHelps.expectCString);
			lstr[len - 1] = sret + "(" + lstr[len - 1] + ");";
			return lstr.join("\n\t\t");
		default:
			ExprHelps.UnExpected(e);
		}
		return "";
	}

	public static function tokenPreDefines( utf8 : Bool, cr = true ) {
		var CRLF = cr ? "\r\n" : "\n";
		var buffer = new StringBuf();
		buffer.add("// Generated by haxelib lex");
		buffer.add(CRLF);
		if (utf8) {
			buffer.add("#define LEXCHAR unsigned char"); // don't remove "unsigned"
		} else {
			buffer.add("#define LEXCHAR unsigned short");
			buffer.add(CRLF);
			buffer.add("#define LEXCHAR_UCS2");
		}
		buffer.add(CRLF);
		buffer.add("#define rlex_char(lex, i)     (((LEXCHAR *)(lex)->src)[i])");
		buffer.add(CRLF);
		buffer.add("#define rlex_current(lex)     (((LEXCHAR *)(lex)->src) + (lex)->pos.min)");
		buffer.add(CRLF);
		return buffer.toString();
	}

	public static function slrTablePrint( lexe : lm.LexEngine, base : lm.ParserBase ) {
		var f = sys.io.File.write("cslr-table.txt");
		f.writeString("\nProduction:\n");
		f.writeString(debug.SLRPrint.production(base));
		f.writeString("\n");
		f.writeString(debug.SLRPrint.table(base, lexe, lexe.entrys));
		f.close();
	}

	/*
	 * default code of slr switch-default
	 */
	public static function slrUnMatching( cr = true ) {
		var CRLF = cr ? "\r\n" : "\n";
		var buffer = new StringBuf();
		/*
		 * struct rstream_tok *t = stream_peek(0);
		 * fprintf(stderr, "UnExpepted: \"");
		 * for (int i = t->pos.min; i < t->pos.max; i++ )
		 *     fprintf(stderr, "%c", rlex_char(stream->lex, i));
		 * fprintf(stderr, "\" at %d-%d\n", t->pos.min, t->pos.max);
		 * exit(-1);
		 */
		buffer.add("struct rstream_tok *t = stream_peek(0);");
		buffer.add(CRLF);
		buffer.add("\t\tfprintf(stderr, \"UnExpepted: \\\"\");");
		buffer.add(CRLF);
		buffer.add("\t\tfor (int i = t->pos.min; i < t->pos.max; i++ )");
		buffer.add(CRLF);
		buffer.add("\t\t\tfprintf(stderr, \"%c\", rlex_char(stream->lex, i));");
		buffer.add(CRLF);
		buffer.add("\t\tfprintf(stderr, \"\\\" at %d-%d\\n\", t->pos.min, t->pos.max);");
		buffer.add(CRLF);
		buffer.add("\t\texit(-1);");
		buffer.add(CRLF);
		return buffer.toString();
	}

	public static function lexUnMatching( cr = true ) {
		var CRLF = cr ? "\r\n" : "\n";
		var buffer = new StringBuf();
		buffer.add("fprintf(stderr, \"UnExpepted: '%c' at %d-%d\\n\", ");
		buffer.add("rlex_char(lex, lex->pos.max), lex->pos.max,lex->pos.min);");
		buffer.add(CRLF);

		buffer.add("\t\texit(-1);");
		buffer.add(CRLF);
		return buffer.toString();
	}
}
