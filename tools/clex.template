// For template variables, please check CLexer.Config

::if (utf8)::
typedef unsigned char rlexsrc;
#define rlex_char(lex, i)     ((lex)->src[i])
#define rlex_current(lex)     ((lex)->src + (lex)->pos.min)
::else::
typedef unsigned short rlexsrc;
#define rlex_char(lex, i)     (((unsigned short*)(lex)->src)[i])
#define rlex_current(lex)     (((unsigned short*)(lex)->src) + (lex)->pos.min)
#define LEX_UCS2_SRC
::end::

::if bit16::
#define LEX_UCS2_TABLE
::end::

static unsigned ::if (bit16):: short ::else:: char ::end:: _lextable[] = {
::table::
};

#define LEX_TABSIZE      ::tabsize::
#define LEX_TABSPAN      ::per::
#define LEX_EXIT(s)      (_lextable[(LEX_TABSIZE - 1) - (s)])
#define LEX_TRANS(s, c)  (_lextable[((s) * LEX_TABSPAN) + (c)])

static int _entry(struct rlex*, int);

::foreach entrys::
#define ::name::_BEGIN    ::begin::
#define ::name::()        (_entry(lex, ::begin::))
::end::
static int _cases(struct rlex* lex, int _q) {
	int _ret = ::eof::;
	switch(_q) {
::foreach cases::
	case ::index:::::if (!faildown)::
	{
		::action::
	}
	break;::end::
::end::
	default:
	{
		::epsilon::
	}
	break;
	}
	return _ret;
}
::foreach entrys::
#undef ::name::
::end::

static int _entry(struct rlex* lex, int begin) {
	if (rlex_end(lex))
		return ::eof::;
	int c;
	int i = lex->pos.max;
	int state = begin;
	int prev = begin;
	while(i < lex->size) {
		c = rlex_char(lex, i++);
::if ((per == 128) || (!utf8))::
		if (c > ::(per - 1)::)
			c = ::(per - 1)::;
::end::
		state = LEX_TRANS(state, c);
		if (state >= ::nsegs::)
			break;
		prev = state;
	}
	lex->pos.min = i; // if UnMatached then pmin >= pmax
	if (state == ::invalid::) {
		state = prev;
		i--;
	}
	int q = LEX_EXIT(state);
	if (i > lex->pos.max && q < ::nrules::) {
		lex->pos.min = lex->pos.max;
		lex->pos.max = i;
	} else {
		q = LEX_EXIT(begin);
	}
	return _cases(lex, q);
}
static int __token(struct rlex* lex) {
	return _entry(lex, ::entrybegin:: );
}

// public function
void ::path.file::_lexinit(struct rlex* lex, rlexsrc *src, int size) {
	lex->pos = (struct rlex_position){0, 0};
	lex->size = size;
	lex->src = (unsigned char*)src;
	lex->token = __token;
}
