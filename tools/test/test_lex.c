// Generated by haxelib lex
#define LEXCHAR unsigned char
#define rlex_char(lex, i)     (((LEXCHAR *)(lex)->src)[i])
#define rlex_current(lex)     (((LEXCHAR *)(lex)->src) + (lex)->pos.min)
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "rlex.h"
#include "rstream.h"

enum token {
	Eof = 0,
	CInt,
	OpMul,
	OpDiv,
	OpAdd,
	OpSub,
	UnMathed,
};

// For template variables, please check CLexer.Config

const static unsigned  char  _lextable[] = {
// STATE 0
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x01,0xFF,0xFF,0x01,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x06,0xFF,0x05,0xFF,0x04,
0x03,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 1
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x01,0xFF,0xFF,0x01,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 2
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// EXIT
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x04,0x02,0x03,0x05,0x01,0x01,0x00,0xFF
};

#define LEX_TABSIZE      400
#define LEX_TABSPAN      128
#define LEX_EXIT(s)      (_lextable[(LEX_TABSIZE - 1) - (s)])
#define LEX_TRANS(s, c)  (_lextable[((s) * LEX_TABSPAN) + (c)])

static int _entry(struct rlex*, int);


#define TOKEN_BEGIN    0
#define token()        (_entry(lex, 0))

static int _cases(struct rlex* lex, int _q) {
	int _ret = Eof;
	switch(_q) {

	case 0:
	{
		_ret = (token() );
	}
	break;

	case 1:
	{
		_ret = (CInt);
	}
	break;

	case 2:
	{
		_ret = (OpAdd);
	}
	break;

	case 3:
	{
		_ret = (OpSub);
	}
	break;

	case 4:
	{
		_ret = (OpMul);
	}
	break;

	case 5:
	{
		_ret = (OpDiv);
	}
	break;

	default:
	{
		printf("UnMatched : '%c' at %d-%d\n", rlex_char(lex, lex->pmax), lex->pmax, lex->pmin);
		exit(-1);
		_ret = (0 );
	}
	break;

	}
	return _ret;
}

#undef token


static int _entry(struct rlex* lex, int begin) {
	if (rlex_end(lex)) {
		lex->pos.min = lex->pos.max;
		return Eof;
	}
	int c;
	int i = lex->pos.max;
	int state = begin;
	int prev = begin;
	while(i < lex->size) {
		c = rlex_char(lex, i++);

		if (c > 127)
			c = 127;

		state = LEX_TRANS(state, c);
		if (state >= 3)
			break;
		prev = state;
	}
	lex->pos.min = i; // if UnMatached then pmin >= pmax
	if (state == 255) {
		state = prev;
		i--;
	}
	int q = LEX_EXIT(state);
	if (i > lex->pos.max && q < 6) {
		lex->pos.min = lex->pos.max;
		lex->pos.max = i;
	} else {
		q = LEX_EXIT(begin);
	}
	return _cases(lex, q);
}
static int __token(struct rlex* lex) {
	return _entry(lex, 0 );
}

// public function
void test_init_lexeme(struct rlex* lex, LEXCHAR *src, int size) {
	lex->pos = (struct rlex_position){0, 0};
	lex->size = size;
	lex->src = src;
	lex->token = __token;
}
 // lexer end

// normal c code here
