#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include "rlex.h"
#include "rstream.h"

static int int_of_string(struct rstream *stream, const struct rstream_tok *t)
{
	const LEXCHAR *source = stream->lex->src;
	unsigned char buff[32];
	int i = 0;
	int j = t->pmin;
	int len = t->pmax - t->pmin;
	while (i < len) {
		buff[i] = (unsigned char)source[j + i];
		i++;
	}
	buff[i] = 0;
	return atoi(buff);
}

%% // parser starts

%FUNC(CInt, int, int_of_string)        // Declare how CInt(n) extracts n
%FUNC(CFloat, float, float_of_string)  // CFloat(f)
%FUNC(CString, char *, of_string)      // CString(s)

%DEF(int)         // (Optianal), Declare a default type if "function" does not explicitly declare the type
                  // default is (void *)

%START(main)      // If omitted, then the default is the first "function"
%LEFT("+", "-")   // (Optianal), Operators precedence. also %RIGHT, %NONASSOC
%LEFT("*", "/")   // The lower have higher priority.

let main = function : int // type(": int") is optianal, If not present then default is %DEF()
| [e = expr, Eof] ->
	e

let expr = function
| [e1 = expr, "+", e2 = expr] ->
	e1 + e2
| [e1 = expr, "-", e2 = expr] ->
	e1 - e2
| [e1 = expr, "*", e2 = expr] ->
	e1 * e2
| [e1 = expr, "/", e2 = expr] ->
	e1 / e2
| [CInt(n)] ->
	n
// | _ ->  // Commented out because we use the error handling provided by default

%%

// auto generated by lex "NAME_init_lexeme"
void test_init_lexeme(struct rlex* lex, LEXCHAR *src, int size);

int main(int argc, char** argv) {
	struct rlex lex;
	struct rstream stream;
	char *text = "3 + 9 * 3 - 1 / 1 + 1";

	// init lexer
	test_init_lexeme(&lex, text, strlen(text));

	// init simple LR parser
	rstream_init(&stream, &lex);

	// PREFIX_main
	const int result = test_main(&stream);
	printf("result : %d === %d\n", result, 3 + 9 * 3 - 1 / 1 + 1);
	return 0;
}
