// Generated by haxelib lex
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "rlex.h"

enum token {
	Eof = 0,
	CInt,
	CIdent,
	CString,  // "strinig"
	CQString, // 'string'
	OpMul,
	OpDiv,
	OpAdd,
	OpSub,
	UnMathed,
};


typedef unsigned char rlexsrc;
#define rlex_char(lex, i)     ((lex)->src[i])
#define rlex_current(lex)     ((lex)->src + (lex)->pmin)


static unsigned  char  _lextable[] = {
// STATE 0
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x01,0xFF,0x14,0xFF,0xFF,0xFF,0xFF,0x13,0xFF,0xFF,0x12,0x11,0xFF,0x10,0xFF,0x0F,
0x0E,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0xFF,0xFF,0xFF,0xFF,0x03,
0xFF,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 1
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 2
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 3
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0xFF,0xFF,0xFF,0xFF,0x03,
0xFF,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 4
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x0D,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x06,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
// STATE 5
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0xFF,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
// STATE 6
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x0C,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
// STATE 7
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0B,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x09,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
// STATE 8
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0xFF,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
// STATE 9
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0A,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
// EXIT 
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x08,0x09,0x06,0x04,0x05,
0x07,0x02,0x0A,0x0B,0x0D,0x0E,0x0F,0x0F,0xFF,0x0C,0x0C,0xFF,0x01,0x03,0x00,0xFF
};

#define LEX_TABSIZE      1312
#define LEX_TABSPAN      128
#define LEX_EXIT(s)      (_lextable[(LEX_TABSIZE - 1) - (s)])
#define LEX_TRANS(s, c)  (_lextable[((s) * LEX_TABSPAN) + (c)])

static int _entry(struct rlex*, int);

static int _cases(struct rlex* lex, int _q) {

#   define TOKEN_BEGIN    0
#   define TOKEN()        (_entry(lex, 0))

#   define STR_BEGIN    4
#   define STR()        (_entry(lex, 4))

#   define QSTR_BEGIN    7
#   define QSTR()        (_entry(lex, 7))

	int _ret = Eof;
	switch(_q) {
	
	case 0:
		
		{
		_ret = TOKEN();

		}
		break;
		
	
	case 1:
		
		{
		_ret = CIdent;

		}
		break;
		
	
	case 2:
		
	
	case 3:
		
		{
		_ret = CInt;

		}
		break;
		
	
	case 4:
		
		{
		_ret = OpAdd;

		}
		break;
		
	
	case 5:
		
		{
		_ret = OpSub;

		}
		break;
		
	
	case 6:
		
		{
		_ret = OpMul;

		}
		break;
		
	
	case 7:
		
		{
		_ret = OpDiv;

		}
		break;
		
	
	case 8:
		
		{
		int min = lex->pmin;
		enum token t = STR();
		if (t == Eof) {
		printf("UnClosed String: %d-%d",min, lex->pmax);
		exit(-1);
		}
	lex->pmin = min;
		_ret = // position union
	t;

		}
		break;
		
	
	case 9:
		
		{
		int min = lex->pmin;
		enum token t = QSTR();
		if (t == Eof) {
		printf("UnClosed String: %d-%d",min, lex->pmax);
		exit(-1);
		}
	lex->pmin = min;
		_ret = t;

		}
		break;
		
	
	case 10:
		
		{
		_ret = CString;

		}
		break;
		
	
	case 11:
		
		{
		_ret = STR();

		}
		break;
		
	
	case 12:
		
		{
		_ret = STR();

		}
		break;
		
	
	case 13:
		
		{
		_ret = CQString;

		}
		break;
		
	
	case 14:
		
		{
		_ret = QSTR();

		}
		break;
		
	
	case 15:
		
		{
		_ret = QSTR();

		}
		break;
		
	
	default:
		{
		_ret = UnMathed;

		}
	}
	return _ret;
}

static int _entry(struct rlex* lex, int begin) {
	if (rlex_end(lex))
		return Eof;
	int c;
	int i = lex->pmax;
	int state = begin;
	int prev = begin;
	while(i < lex->size) {
		c = rlex_char(lex, i++);
		state = LEX_TRANS(state, c);
		if (state >= 10)
			break;
		prev = state;
	}
	lex->pmin = i; // if UnMatached then pmin >= pmax
	if (state == 255) {
		state = prev;
		i--;
	}
	int q = LEX_EXIT(state);
	if (i > lex->pmax && q < 16) {
		lex->pmin = lex->pmax;
		lex->pmax = i;
	} else {
		q = LEX_EXIT(begin);
	}
	return _cases(lex, q);
}
static int __token(struct rlex* lex) {
	return _entry(lex, 0 );
}

// public function
void test_lexinit(struct rlex* lex, rlexsrc *src, int size) {
	lex->pmin = lex->pmax = 0;
	lex->size = size;
	lex->src = (unsigned char*)src;
	lex->token = __token;
}


int main(int argc, char** argv) {
	char buff[256];
	char* text = "1 + 2 - \"string\" * ident / 101 [";
	struct rlex lex;

	test_lexinit(&lex, text, strlen(text)); // filename + "lexinit"

	while(1) {
		int tok = rlex_token(&lex);
		switch(tok) {
		case Eof:
			goto Endloop;
		case CInt:
		{
			long n = atol(rlex_current(&lex));
			printf("%ld\n", n);
		}
			break;
		case CIdent:
		{
			int size = rlex_cursize(&lex);
			memcpy(buff, rlex_current(&lex), size);
			buff[size] = 0;
			printf("%s\n", buff);
		}
			break;
		case CString:
		case CQString:
		{
			int size = rlex_cursize(&lex);
			memcpy(buff, rlex_current(&lex), size);
			buff[size] = 0;
			printf("%s\n", buff);
		}
			break;
		case OpMul:
			printf("*\n");
			break;
		case OpDiv:
			printf("/\n");
			break;
		case OpAdd:
			printf("+\n");
			break;
		case OpSub:
			printf("-\n");
			break;
		case UnMathed:
			printf("UnMathed : %c\n", rlex_char(&lex, lex.pmax)); // if error then pmin >= pmax
			goto Endloop;
			break;
		default:
			break;
		}
	}
	Endloop:
	return 0;
}
